Timer unit: 1e-09 s

Total time: 24.4924 s
File: /workspaces/turtle-toolkit/src/turtle_toolkit/modules/register_file.py
Function: update_state at line 131

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
   131                                               @profile
   132                                               def update_state(self) -> None:
   133   1392500  328195287.0    235.7      1.3          if self.state.pending_register is not None and self.state.pending_value is None:
   134                                                       raise ValueError(
   135                                                           f"Pending value for register {self.state.pending_register} is None."
   136                                                       )
   137   1392500  642495090.0    461.4      2.6          if self.state.pending_register == RegisterIndex.STATUS:
   138                                                       raise IndexError("STATUS can not be written directly")
   139   1392500  481832408.0    346.0      2.0          elif self.state.pending_register == RegisterIndex.ACC:
   140                                                       raise IndexError("ACC can not be written directly")
   141                                                   elif (
   142   1392500  474828205.0    341.0      1.9              self.state.pending_register in self.state.registers
   143     28200    6229625.0    220.9      0.0              and self.state.pending_value is not None
   144                                                   ):
   145     28200   22041325.0    781.6      0.1              self.state.registers[self.state.pending_register] = self.state.pending_value
   146   1364300  274610750.0    201.3      1.1          elif self.state.pending_register is not None:
   147                                                       raise IndexError(
   148                                                           f"Register index {self.state.pending_register} is not valid."
   149                                                       )
   150   1392500  332568197.0    238.8      1.4          self.state.pending_register = None
   151   1392500  308009595.0    221.2      1.3          self.state.pending_value = None
   152   1392500  323940602.0    232.6      1.3          if self.state.pending_accumulator is not None:
   153   1391500 1200928857.0    863.0      4.9              self.state.registers[RegisterIndex.ACC] = self.state.pending_accumulator
   154   1392500  201306717.0    144.6      0.8          zero = (
   155   1392500 1029286468.0    739.2      4.2              (self.state.pending_accumulator.unsigned_value() == 0)
   156   1392500  295265442.0    212.0      1.2              if self.state.pending_accumulator
   157      1000     123409.0    123.4      0.0              else None
   158                                                   )
   159   1392500  181785412.0    130.5      0.7          positive = (
   160   1392500 2473457026.0   1776.3     10.1              (self.state.pending_accumulator.signed_value() >= 0)
   161   1392500  305592146.0    219.5      1.2              if self.state.pending_accumulator
   162      1000     127473.0    127.5      0.0              else None
   163                                                   )
   164                                           
   165   1392500 1495445697.0   1073.9      6.1          def resolve_next_bit(current_bit: int, pending_bit: Optional[bool]) -> int:
   166                                                       """Resolve the next bit value."""
   167                                                       return int(pending_bit) if pending_bit is not None else current_bit
   168                                           
   169   1392500 1214493703.0    872.2      5.0          def compute_next_status_bit(shift: int, pending: Optional[bool]) -> int:
   170                                                       """Compute the next status bit."""
   171                                                       current_bit = (current_status_value >> shift) & 1
   172                                                       return resolve_next_bit(current_bit, pending) << shift
   173                                           
   174                                                   # Extract the current status register value
   175   4177500 1238930226.0    296.6      5.1          current_status_value = self.state.registers[
   176   1392500  354671622.0    254.7      1.4              RegisterIndex.STATUS
   177   1392500  748114890.0    537.2      3.1          ].unsigned_value()
   178                                           
   179                                                   # Compute the next status register value
   180   1392500  205275506.0    147.4      0.8          next_status_value = 0
   181   1392500 1545616126.0   1110.0      6.3          next_status_value |= compute_next_status_bit(0, zero)
   182   1392500 1261813549.0    906.1      5.2          next_status_value |= compute_next_status_bit(1, positive)
   183   1392500 1345705090.0    966.4      5.5          next_status_value |= compute_next_status_bit(2, self.state.pending_carry_flag)
   184   2785000 1357124425.0    487.3      5.5          next_status_value |= compute_next_status_bit(
   185   1392500  297357680.0    213.5      1.2              3, self.state.pending_signed_overflow
   186                                                   )
   187                                           
   188                                                   # Update the STATUS register with the computed value
   189   1392500 4545256136.0   3264.1     18.6          self.state.registers[RegisterIndex.STATUS] = DataBusValue(next_status_value)

 24.49 seconds - /workspaces/turtle-toolkit/src/turtle_toolkit/modules/register_file.py:131 - update_state
